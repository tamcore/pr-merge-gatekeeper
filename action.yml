name: 'Merge Gatekeeper'
description: 'Ensures all CI checks pass before allowing a PR to be merged. Polls check runs and commit statuses, retrying while checks are in progress.'
author: 'Philipp'

branding:
  icon: 'shield'
  color: 'green'

inputs:
  token:
    description: 'GitHub token to access PR commit statuses and checks'
    required: false
    default: ${{ github.token }}
  initial-delay:
    description: 'Seconds to sleep before the first check'
    required: false
    default: '5'
  max-retries:
    description: 'Number of retries while checks are still in progress'
    required: false
    default: '5'
  polling-interval:
    description: 'Seconds to wait between retry attempts'
    required: false
    default: '60'
  ignored-name-patterns:
    description: 'Newline-separated list of regex patterns to exclude jobs from evaluation'
    required: false
    default: ''
  full-details-summary:
    description: 'Show all checks in the summary (not just failures)'
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
    - name: Check CI Status
      uses: actions/github-script@v8
      with:
        github-token: ${{ inputs.token }}
        script: |
          // Inputs
          const initialDelay = parseInt('${{ inputs.initial-delay }}', 10);
          const maxRetries = parseInt('${{ inputs.max-retries }}', 10);
          const pollingInterval = parseInt('${{ inputs.polling-interval }}', 10);
          const ignoredPatterns = `${{ inputs.ignored-name-patterns }}`
            .split('\n')
            .map(p => p.trim())
            .filter(p => p.length > 0)
            .map(p => new RegExp(p));
          const fullDetailsSummary = '${{ inputs.full-details-summary }}' === 'true';

          // Determine the commit SHA to check
          const sha = context.payload.pull_request?.head?.sha || context.sha;
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const currentJob = process.env.GITHUB_JOB;

          core.info(`Checking commit: ${sha}`);
          core.info(`Current job: ${currentJob}`);

          /**
           * Fetch all check runs for the commit, deduplicated by app+name (keeping highest ID)
           */
          async function fetchCheckRuns() {
            const checkRuns = new Map(); // Key: "app_slug/name", Value: check run object

            // Get all check suites for the ref
            const suites = await github.paginate(
              github.rest.checks.listSuitesForRef,
              { owner, repo, ref: sha, per_page: 100 }
            );

            // For each suite, get all check runs
            for (const suite of suites) {
              const runs = await github.paginate(
                github.rest.checks.listForSuite,
                { owner, repo, check_suite_id: suite.id, per_page: 100 }
              );

              for (const run of runs) {
                // Skip runs with uninterpreted template syntax
                if (run.name.includes('${{')) {
                  core.debug(`Skipping check run with template syntax: ${run.name}`);
                  continue;
                }

                const key = `${run.app?.slug || 'unknown'}/${run.name}`;
                const existing = checkRuns.get(key);

                // Keep the run with the highest ID (most recent)
                if (!existing || run.id > existing.id) {
                  checkRuns.set(key, run);
                }
              }
            }

            return Array.from(checkRuns.values());
          }

          /**
           * Fetch all commit statuses for the commit
           */
          async function fetchCommitStatuses() {
            const statuses = await github.paginate(
              github.rest.repos.listCommitStatusesForRef,
              { owner, repo, ref: sha, per_page: 100 }
            );

            // Deduplicate by context (keep the most recent, which is first in the list)
            const seen = new Set();
            return statuses.filter(status => {
              if (seen.has(status.context)) {
                return false;
              }
              seen.add(status.context);
              return true;
            });
          }

          /**
           * Classify a check run into a category
           */
          function classifyCheckRun(run) {
            const name = run.name;
            const appSlug = run.app?.slug || 'unknown';
            const status = run.status;
            const conclusion = run.conclusion;

            // Check if this is the current job (self)
            if (name === currentJob && appSlug === 'github-actions') {
              return 'self';
            }

            // Check if this matches any ignored pattern
            for (const pattern of ignoredPatterns) {
              if (pattern.test(name)) {
                return 'ignored';
              }
            }

            // Check if still running
            if (status === 'queued' || status === 'in_progress') {
              return 'running';
            }

            // Check if successful (success, skipped, or neutral are all OK)
            if (conclusion === 'success' || conclusion === 'skipped' || conclusion === 'neutral') {
              return 'success';
            }

            // Everything else is a failure
            return 'failure';
          }

          /**
           * Classify a commit status into a category
           */
          function classifyStatus(status) {
            const context = status.context;
            const state = status.state;

            // Check if this matches any ignored pattern
            for (const pattern of ignoredPatterns) {
              if (pattern.test(context)) {
                return 'ignored';
              }
            }

            // Check if still pending
            if (state === 'pending') {
              return 'running';
            }

            // Check if successful
            if (state === 'success') {
              return 'success';
            }

            // Everything else is a failure
            return 'failure';
          }

          /**
           * Perform a single check and return the results
           */
          async function performCheck() {
            const checkRuns = await fetchCheckRuns();
            const statuses = await fetchCommitStatuses();

            const results = [];
            let hasFailure = false;
            let hasRunning = false;
            let foundSelf = false;

            // Process check runs
            for (const run of checkRuns) {
              const category = classifyCheckRun(run);
              results.push({
                name: run.name,
                type: 'check_run',
                category,
                status: run.status,
                conclusion: run.conclusion,
                url: run.html_url
              });

              if (category === 'self') foundSelf = true;
              if (category === 'failure') hasFailure = true;
              if (category === 'running') hasRunning = true;
            }

            // Process commit statuses
            for (const status of statuses) {
              const category = classifyStatus(status);
              results.push({
                name: status.context,
                type: 'status',
                category,
                status: status.state,
                conclusion: status.state,
                url: status.target_url
              });

              if (category === 'failure') hasFailure = true;
              if (category === 'running') hasRunning = true;
            }

            if (!foundSelf) {
              core.warning('Could not find current job in check runs. This may be due to API lag.');
            }

            return { results, hasFailure, hasRunning, foundSelf };
          }

          /**
           * Sleep for a specified number of seconds
           */
          function sleep(seconds) {
            return new Promise(resolve => setTimeout(resolve, seconds * 1000));
          }

          /**
           * Main retry loop
           */
          async function run() {
            const runAttempt = parseInt(process.env.GITHUB_RUN_ATTEMPT || '1', 10);

            // If this is a re-run, do an immediate check first
            if (runAttempt > 1) {
              core.info('Re-run detected, performing immediate check...');
              const { results, hasFailure, hasRunning } = await performCheck();

              if (!hasRunning) {
                return { results, hasFailure };
              }
              core.info('Checks still running, will continue with retry loop...');
            }

            // Initial delay before first check
            core.info(`Waiting ${initialDelay} seconds before first check...`);
            await sleep(initialDelay);

            let lastResults = null;
            let lastHasFailure = false;

            for (let attempt = 0; attempt <= maxRetries; attempt++) {
              if (attempt > 0) {
                core.info(`Waiting ${pollingInterval} seconds before retry ${attempt}/${maxRetries}...`);
                await sleep(pollingInterval);
              }

              core.info(`Performing check (attempt ${attempt + 1}/${maxRetries + 1})...`);
              const { results, hasFailure, hasRunning } = await performCheck();

              lastResults = results;
              lastHasFailure = hasFailure;

              if (!hasRunning) {
                core.info('All checks have completed.');
                return { results, hasFailure };
              }

              const runningCount = results.filter(r => r.category === 'running').length;
              core.info(`${runningCount} check(s) still running...`);
            }

            // Max retries exhausted
            core.warning('Max retries exhausted with checks still running.');
            return { results: lastResults, hasFailure: true, timedOut: true };
          }

          /**
           * Generate the GitHub Step Summary
           */
          function generateSummary(results, timedOut) {
            const categoryEmoji = {
              self: 'ðŸ”µ',
              ignored: 'âšª',
              running: 'ðŸŸ¡',
              success: 'ðŸŸ¢',
              failure: 'ðŸ”´'
            };

            const categoryLabel = {
              self: 'Current Job',
              ignored: 'Ignored',
              running: 'Running',
              success: 'Success',
              failure: 'Failed'
            };

            // Filter results for summary
            let summaryResults = results;
            if (!fullDetailsSummary) {
              // Only show failures, running, and self
              summaryResults = results.filter(r =>
                r.category === 'failure' || r.category === 'running' || r.category === 'self'
              );
            }

            // Sort by category priority: failure, running, success, ignored, self
            const categoryOrder = { failure: 0, running: 1, success: 2, ignored: 3, self: 4 };
            summaryResults.sort((a, b) => categoryOrder[a.category] - categoryOrder[b.category]);

            // Build summary table
            let summary = '## Merge Gatekeeper Results\n\n';

            if (timedOut) {
              summary += 'âš ï¸ **Warning:** Max retries exhausted with checks still running.\n\n';
            }

            const failureCount = results.filter(r => r.category === 'failure').length;
            const runningCount = results.filter(r => r.category === 'running').length;
            const successCount = results.filter(r => r.category === 'success').length;
            const ignoredCount = results.filter(r => r.category === 'ignored').length;

            summary += `**Summary:** ${successCount} passed, ${failureCount} failed, ${runningCount} running, ${ignoredCount} ignored\n\n`;

            if (summaryResults.length > 0) {
              summary += '| Status | Name | Type | Details |\n';
              summary += '|--------|------|------|---------||\n';

              for (const result of summaryResults) {
                const emoji = categoryEmoji[result.category];
                const label = categoryLabel[result.category];
                const name = result.url ? `[${result.name}](${result.url})` : result.name;
                const type = result.type === 'check_run' ? 'Check Run' : 'Status';
                const details = result.conclusion || result.status || '-';

                summary += `| ${emoji} ${label} | ${name} | ${type} | ${details} |\n`;
              }
            } else {
              summary += '_No checks to display._\n';
            }

            return summary;
          }

          // Execute the main logic
          try {
            const { results, hasFailure, timedOut } = await run();

            // Generate and write summary
            const summary = generateSummary(results, timedOut);
            await core.summary.addRaw(summary).write();

            // Exit with appropriate status
            if (hasFailure) {
              const failedChecks = results.filter(r => r.category === 'failure');
              core.setFailed(`${failedChecks.length} check(s) failed: ${failedChecks.map(r => r.name).join(', ')}`);
            } else {
              core.info('All required checks passed!');
            }
          } catch (error) {
            core.setFailed(`Action failed with error: ${error.message}`);
          }
