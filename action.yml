name: 'PR Merge Gatekeeper'
description: 'Ensures all CI checks pass before merging PRs. Polls check runs and statuses, retrying in-progress checks.'
author: 'tamcore'

branding:
  icon: 'shield'
  color: 'green'

inputs:
  github-token:
    description: 'GitHub token to access PR commit statuses and checks'
    required: false
    default: ${{ github.token }}
  initial-delay-seconds:
    description: 'Seconds to sleep before the first check'
    required: false
    default: '5'
  max-retries:
    description: 'Number of retries while checks are still in progress'
    required: false
    default: '5'
  polling-interval-seconds:
    description: 'Seconds to wait between retry attempts'
    required: false
    default: '60'
  ignored-name-patterns:
    description: 'Newline-separated list of regex patterns to exclude jobs from evaluation'
    required: false
    default: ''
  full-details-summary:
    description: 'Show all checks in the summary (not just failures)'
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
    - name: Check CI Status
      uses: actions/github-script@v8
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          // Inputs
          const initialDelay = parseInt('${{ inputs.initial-delay-seconds }}', 10);
          const maxRetries = parseInt('${{ inputs.max-retries }}', 10);
          const pollingInterval = parseInt('${{ inputs.polling-interval-seconds }}', 10);
          const ignoredPatterns = `${{ inputs.ignored-name-patterns }}`
            .split('\n')
            .map(p => p.trim())
            .filter(p => p.length > 0)
            .map(p => new RegExp(p));
          const fullDetailsSummary = '${{ inputs.full-details-summary }}' === 'true';

          // Determine the commit SHA to check
          const sha = context.payload.pull_request?.head?.sha || context.sha;
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const currentJob = process.env.GITHUB_JOB;

          core.info(`Checking commit: ${sha}`);
          core.info(`Current job: ${currentJob}`);

          /**
           * Fetch all check runs for the commit, deduplicated by app+name (keeping highest ID)
           */
          async function fetchCheckRuns() {
            try {
              const checkRuns = new Map(); // Key: "app_slug/name", Value: check run object

              // Get all check suites for the ref
              const suites = await github.paginate(
                github.rest.checks.listSuitesForRef,
                { owner, repo, ref: sha, per_page: 100 }
              );

              // For each suite, get all check runs
              for (const suite of suites) {
                const runs = await github.paginate(
                  github.rest.checks.listForSuite,
                  { owner, repo, check_suite_id: suite.id, per_page: 100 }
                );

                for (const run of runs) {
                  // Skip runs with uninterpreted template syntax
                  // Note: We construct the pattern to avoid GitHub parsing it as an expression
                  const templatePattern = '$' + '{{';
                  if (run.name.includes(templatePattern)) {
                    core.debug(`Skipping check run with template syntax: ${run.name}`);
                    continue;
                  }

                  const key = `${run.app?.slug || 'unknown'}/${run.name}`;
                  const existing = checkRuns.get(key);

                  // Keep the run with the highest ID (most recent)
                  if (!existing || run.id > existing.id) {
                    checkRuns.set(key, run);
                  }
                }
              }

              return Array.from(checkRuns.values());
            } catch (error) {
              // Handle API errors gracefully (e.g., HTML error pages from GitHub)
              core.warning(`GitHub API error while fetching check runs: ${error.message}`);
              return [];
            }
          }

          /**
           * Fetch all commit statuses for the commit
           */
          async function fetchCommitStatuses() {
            try {
              const statuses = await github.paginate(
                github.rest.repos.listCommitStatusesForRef,
                { owner, repo, ref: sha, per_page: 100 }
              );

              // Deduplicate by context (keep the most recent, which is first in the list)
              const seen = new Set();
              return statuses.filter(status => {
                if (seen.has(status.context)) {
                  return false;
                }
                seen.add(status.context);
                return true;
              });
            } catch (error) {
              // Handle API errors gracefully (e.g., HTML error pages from GitHub)
              core.warning(`GitHub API error while fetching commit statuses: ${error.message}`);
              return [];
            }
          }

          /**
           * Classify a check run into a category
           */
          function classifyCheckRun(run) {
            const name = run.name;
            const appSlug = run.app?.slug || 'unknown';
            const status = run.status;
            const conclusion = run.conclusion;

            // Check if this is the current job (self)
            if (name === currentJob && appSlug === 'github-actions') {
              return 'self';
            }

            // Check if this matches any ignored pattern
            for (const pattern of ignoredPatterns) {
              if (pattern.test(name)) {
                return 'ignored';
              }
            }

            // Check if still running
            if (status === 'queued' || status === 'in_progress') {
              return 'running';
            }

            // Check if successful (success, skipped, or neutral are all OK)
            if (conclusion === 'success' || conclusion === 'skipped' || conclusion === 'neutral') {
              return 'success';
            }

            // Everything else is a failure
            return 'failure';
          }

          /**
           * Classify a commit status into a category
           */
          function classifyStatus(status) {
            const context = status.context;
            const state = status.state;

            // Check if this matches any ignored pattern
            for (const pattern of ignoredPatterns) {
              if (pattern.test(context)) {
                return 'ignored';
              }
            }

            // Check if still pending
            if (state === 'pending') {
              return 'running';
            }

            // Check if successful
            if (state === 'success') {
              return 'success';
            }

            // Everything else is a failure
            return 'failure';
          }

          /**
           * Perform a single check and return the results
           */
          async function performCheck() {
            const checkRuns = await fetchCheckRuns();
            const statuses = await fetchCommitStatuses();

            // If both API calls failed, throw an error to trigger retry
            if (checkRuns.length === 0 && statuses.length === 0) {
              core.warning('‚ö†Ô∏è GitHub API returned no data (possible temporary API issue). Will retry...');
            }

            core.info(`Found ${checkRuns.length} check runs`);
            core.info(`Found ${statuses.length} commit statuses`);

            const results = [];
            let hasFailure = false;
            let hasRunning = false;
            let foundSelf = false;

            // Process check runs
            for (const run of checkRuns) {
              const category = classifyCheckRun(run);

              // Calculate duration if both timestamps are available
              let duration = null;
              if (run.started_at && run.completed_at) {
                duration = (new Date(run.completed_at).getTime() - new Date(run.started_at).getTime()) / 1000;
              }

              results.push({
                name: run.name,
                type: 'check_run',
                category,
                status: run.status,
                conclusion: run.conclusion,
                url: run.html_url,
                startedAt: run.started_at || null,
                duration
              });

              // Log status for each check run
              if (category === 'self') {
                core.info(`  üôà Skipping current running check: ${run.name}`);
                foundSelf = true;
              } else if (category === 'ignored') {
                core.info(`  üôà Ignoring ${run.name} (matched ignore pattern)`);
              } else if (category === 'running') {
                core.info(`  ‚è≥ ${run.name} is still running (status: ${run.status})`);
                hasRunning = true;
              } else if (category === 'failure') {
                core.info(`  ‚ùå Check run failed: ${run.name} (conclusion: ${run.conclusion})`);
                hasFailure = true;
              } else if (category === 'success') {
                core.info(`  ‚úÖ ${run.name} passed`);
              }
            }

            // Process commit statuses
            for (const status of statuses) {
              const category = classifyStatus(status);

              // Calculate duration if both timestamps are available
              let duration = null;
              if (status.created_at && status.updated_at) {
                duration = (new Date(status.updated_at).getTime() - new Date(status.created_at).getTime()) / 1000;
              }

              results.push({
                name: status.context,
                type: 'status',
                category,
                status: status.state,
                conclusion: status.state,
                url: status.target_url,
                startedAt: status.created_at || null,
                duration
              });

              // Log status for each commit status
              if (category === 'ignored') {
                core.info(`  üôà Ignoring ${status.context} (matched ignore pattern)`);
              } else if (category === 'running') {
                core.info(`  ‚è≥ ${status.context} is pending (state: ${status.state})`);
                hasRunning = true;
              } else if (category === 'failure') {
                core.info(`  ‚ùå Status failed: ${status.context} (state: ${status.state})`);
                hasFailure = true;
              } else if (category === 'success') {
                core.info(`  ‚úÖ ${status.context} passed`);
              }
            }

            if (!foundSelf) {
              core.warning('Could not find current job in check runs. This may be due to API lag.');
            }

            return { results, hasFailure, hasRunning, foundSelf };
          }

          /**
           * Sleep for a specified number of seconds
           */
          function sleep(seconds) {
            return new Promise(resolve => setTimeout(resolve, seconds * 1000));
          }

          /**
           * Main retry loop
           */
          async function run() {
            const runAttempt = parseInt(process.env.GITHUB_RUN_ATTEMPT || '1', 10);

            // If this is a re-run, do an immediate check first
            if (runAttempt > 1) {
              core.info('üîÑ Re-run detected, performing immediate check...');
              const { results, hasFailure, hasRunning } = await performCheck();

              if (!hasRunning) {
                return { results, hasFailure };
              }
              core.info('‚è≥ Checks still running, will continue with retry loop...');
            }

            // Initial delay before first check
            core.info(`‚è≥ Waiting ${initialDelay} seconds before first check...`);
            await sleep(initialDelay);

            let lastResults = null;
            let lastHasFailure = false;

            for (let attempt = 0; attempt <= maxRetries; attempt++) {
              if (attempt > 0) {
                core.info(`‚è≥ Waiting ${pollingInterval} seconds before retry ${attempt}/${maxRetries}...`);
                await sleep(pollingInterval);
              }

              if (attempt === 0) {
                core.info('üîç Performing initial check...');
              } else {
                core.info(`üîç Performing retry ${attempt}/${maxRetries}...`);
              }

              let results, hasFailure, hasRunning;
              try {
                ({ results, hasFailure, hasRunning } = await performCheck());
              } catch (error) {
                core.warning(`‚ö†Ô∏è Error during check (attempt ${attempt}/${maxRetries}): ${error.message}`);
                // On API errors, treat as if checks are still running and continue retrying
                if (attempt === maxRetries) {
                  throw error; // Re-throw on last attempt
                }
                continue; // Skip to next retry
              }

              lastResults = results;
              lastHasFailure = hasFailure;

              if (!hasRunning) {
                core.info('‚úÖ All checks have completed.');
                return { results, hasFailure };
              }

              const runningCount = results.filter(r => r.category === 'running').length;
              core.info(`‚è≥ ${runningCount} check(s) still running...`);
            }

            // Max retries exhausted
            core.warning('Max retries exhausted with checks still running.');
            return { results: lastResults, hasFailure: true, timedOut: true };
          }

          /**
           * Generate the GitHub Step Summary
           */
          function generateSummary(results, timedOut) {
            const fancyInterpretation = {
              self: 'üôà Current job',
              ignored: 'üôà Ignored',
              running: '‚è≥ Still running...',
              success: '‚úÖ All good!',
              failure: '‚ùå Something failed.'
            };

            // Filter results for summary
            let summaryResults = results;
            if (!fullDetailsSummary) {
              // Only show failures, running, and self
              summaryResults = results.filter(r =>
                r.category === 'failure' || r.category === 'running' || r.category === 'self'
              );
            }

            // Sort by category priority: failure, running, success, ignored, self
            const categoryOrder = { failure: 0, running: 1, success: 2, ignored: 3, self: 4 };
            summaryResults.sort((a, b) => categoryOrder[a.category] - categoryOrder[b.category]);

            // Build summary table
            let summary = '## Merge Gatekeeper Results\n\n';

            if (timedOut) {
              summary += '‚ö†Ô∏è **Warning:** Max retries exhausted with checks still running.\n\n';
            }

            const failureCount = results.filter(r => r.category === 'failure').length;
            const runningCount = results.filter(r => r.category === 'running').length;
            const successCount = results.filter(r => r.category === 'success').length;
            const ignoredCount = results.filter(r => r.category === 'ignored').length;

            summary += `**Summary:** ${successCount} successful, ${failureCount} failed, ${runningCount} running, ${ignoredCount} ignored\n\n`;

            if (!fullDetailsSummary && (successCount > 0 || ignoredCount > 0)) {
              summary += `> ‚ÑπÔ∏è ${successCount} successful, ${ignoredCount} ignored. Enable full-details-summary to see them.\n\n`;
            }

            if (summaryResults.length > 0) {
              summary += '| Check Name | Source | Start Time | Duration | Status | Interpreted as |\n';
              summary += '|------------|--------|------------|----------|--------|----------------|\n';

              for (const result of summaryResults) {
                const interpretation = fancyInterpretation[result.category] || '‚ö†Ô∏è Unknown status';
                const name = result.url ? `[${result.name}](${result.url})` : result.name;
                const source = result.type === 'check_run' ? 'check run' : 'status';
                const status = result.conclusion || result.status || '-';
                const startTime = result.startedAt || '-';
                const duration = result.duration != null ? `${Math.round(result.duration)}s` : '-';

                summary += `| ${name} | ${source} | ${startTime} | ${duration} | ${status} | ${interpretation} |\n`;
              }
            } else {
              summary += '_No checks to display._\n';
            }

            return summary;
          }

          // Execute the main logic
          try {
            const { results, hasFailure, timedOut } = await run();

            // Generate and write summary
            const summary = generateSummary(results, timedOut);
            await core.summary.addRaw(summary).write();

            // Exit with appropriate status
            if (hasFailure) {
              const failedChecks = results.filter(r => r.category === 'failure');
              core.setFailed(`‚ùå Some CI checks or statuses failed: ${failedChecks.map(r => r.name).join(', ')}`);
            } else {
              core.info('‚úÖ All CI checks and statuses passed or were skipped.');
            }
          } catch (error) {
            core.setFailed(`Action failed with error: ${error.message}`);
          }
