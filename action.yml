name: 'Merge Gatekeeper'
description: 'Ensures all CI checks pass before allowing a PR to be merged. Polls check runs and commit statuses, retrying while checks are in progress.'
author: 'Philipp'

branding:
  icon: 'shield'
  color: 'green'

inputs:
  token:
    description: 'GitHub token to access PR commit statuses and checks'
    required: false
    default: ${{ github.token }}
  initial-delay:
    description: 'Seconds to sleep before the first check'
    required: false
    default: '5'
  max-retries:
    description: 'Number of retries while checks are still in progress'
    required: false
    default: '5'
  polling-interval:
    description: 'Seconds to wait between retry attempts'
    required: false
    default: '60'
  ignored-name-patterns:
    description: 'Newline-separated list of regex patterns to exclude jobs from evaluation'
    required: false
    default: ''
  full-details-summary:
    description: 'Show all checks in the summary (not just failures)'
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
    - name: Check CI Status
      uses: actions/github-script@v8
      with:
        github-token: ${{ inputs.token }}
        script: |
          // Inputs
          const initialDelay = parseInt('${{ inputs.initial-delay }}', 10);
          const maxRetries = parseInt('${{ inputs.max-retries }}', 10);
          const pollingInterval = parseInt('${{ inputs.polling-interval }}', 10);
          const ignoredPatterns = `${{ inputs.ignored-name-patterns }}`
            .split('\n')
            .map(p => p.trim())
            .filter(p => p.length > 0)
            .map(p => new RegExp(p));
          const fullDetailsSummary = '${{ inputs.full-details-summary }}' === 'true';

          // Determine the commit SHA to check
          const sha = context.payload.pull_request?.head?.sha || context.sha;
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const currentJob = process.env.GITHUB_JOB;

          core.info(`Checking commit: ${sha}`);
          core.info(`Current job: ${currentJob}`);

          /**
           * Fetch all check runs for the commit, deduplicated by app+name (keeping highest ID)
           */
          async function fetchCheckRuns() {
            const checkRuns = new Map(); // Key: "app_slug/name", Value: check run object

            // Get all check suites for the ref
            const suites = await github.paginate(
              github.rest.checks.listSuitesForRef,
              { owner, repo, ref: sha, per_page: 100 }
            );

            // For each suite, get all check runs
            for (const suite of suites) {
              const runs = await github.paginate(
                github.rest.checks.listForSuite,
                { owner, repo, check_suite_id: suite.id, per_page: 100 }
              );

              for (const run of runs) {
                // Skip runs with uninterpreted template syntax
                if (run.name.includes('${{')) {
                  core.debug(`Skipping check run with template syntax: ${run.name}`);
                  continue;
                }

                const key = `${run.app?.slug || 'unknown'}/${run.name}`;
                const existing = checkRuns.get(key);

                // Keep the run with the highest ID (most recent)
                if (!existing || run.id > existing.id) {
                  checkRuns.set(key, run);
                }
              }
            }

            return Array.from(checkRuns.values());
          }

          /**
           * Fetch all commit statuses for the commit
           */
          async function fetchCommitStatuses() {
            const statuses = await github.paginate(
              github.rest.repos.listCommitStatusesForRef,
              { owner, repo, ref: sha, per_page: 100 }
            );

            // Deduplicate by context (keep the most recent, which is first in the list)
            const seen = new Set();
            return statuses.filter(status => {
              if (seen.has(status.context)) {
                return false;
              }
              seen.add(status.context);
              return true;
            });
          }

          // TODO: Implement classification logic
          // TODO: Implement retry loop
          // TODO: Generate summary

          core.info('Merge Gatekeeper initialized');
          core.info(`Initial delay: ${initialDelay}s`);
          core.info(`Max retries: ${maxRetries}`);
          core.info(`Polling interval: ${pollingInterval}s`);
          core.info(`Ignored patterns: ${ignoredPatterns.length}`);
          core.info(`Full details summary: ${fullDetailsSummary}`);
